# flutter_interview
Данный документ охватывает основные вещи,которые могут спросить на собеседовании на позицию flutter-разработчика


**ОБЩИЕ**


ООП(обьектно-ориентирование программирование) - парадигма программирования, основанная на представлении программы в виде совокупности обьектов(сущностей), каждый из которых является экземпляром определенного класса, а классы образуют иерархию наследования.
Абстракция - каждый класс должен представлять лишь ту информацию, которая соответсвует контексту задачи.
Инкапсуляция - обьединение данных и методов, нужных для работы с ними, в одном классе.
Полиморфизм - использование объектов с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.
Наследование - описание нового класс на основе уже существующего с частично или полностью заимствованной функциональностью.


SOLID
Single Responsibility Principle (Принцип единственной ответственности) - каждый класс должен иметь только одну причину для изменения. Он должен отвечать только за одну часть функциональности.
Open-Closed Principle (Принцип открытости-закрытости) - программные сущности должны быть открыты для расширения, но закрыты для модификации. Это достигается путем использования абстракции и полиморфизма.
Liskov Substitution Principle (Принцип подстановки Барбары Лисков) -  функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа не зная об этом.
Interface Segregation Principle (Принцип разделения интерфейса) -  клиенты не должны зависеть от интерфейсов, которые они не используют(клиенты не должны имплементировать логику, которую они не используют). 
Dependency Inversion Principle (Принцип инверсии зависимостей) - модули верхних уровней не должны зависеть от модулей нижних уровней. Классы и верхних, и нижних уровней должны зависеть от одних и тех же абстракций (при чём абстракции не должны знать о деталях).


DAO, DTO, VO, BO
DAO (Data Access Object, объект доступа к данным) — абстрактный интерфейс к какому-либо типу базы данных или иному механизму хранения
DTO (Data Transfer Object, объект переноса данных) - это объект для передачи данных (объектов без поведения) между слоями
VO (Value Object, объект-значение) ⎼ это объект без специальных методов, имеющий набор свойств (полей) примитивных типов данных или тоже Value object
BO (Business Object, объект бизнеса) - это объект, который представляют некую сущность из определенного «домена», то есть отрасли, для которой разработано приложение


DI и Service Locator
DI - процесс предоставления внешней зависимости программному компоненту(например, через конструктор).
Service Locator - синглтон / класс с набором статических методов
Минусы service locator:
 Доступ может производиться из любой части программы
 Скрытие зависимостей частей программы
 Делает код более сложным для поддержки
 Делает код более сложным для тестирования




**АРХИТЕКТУРА**


Архитектура
Архитектура - это набор решений по организации программы. Таких, как деление программы на слои, построение связей между ними, управление состоянием, связь с UI. Хорошая архитектура делает слои в приложении слабо связанными, что упрощает внесение изменений, повышает тестируемость кода, упрощает систему


Чистая архитектура
Чистая архитектура - архитектура, которая следует SOLID и делится на три независимых слоя:
 Data (datasources, models, repositories) получение данных извне
 Domain (entities, repositories interfaces, usecases) бизнес правила
 Presentation (bloc, pages, widgets) отображение




**DART**

Dart - компилируемый высокоуровневый язык программирования с объектно-ориентированной парадигмой, разработанный компание Google и выпущенный в 2011 году. Разрабатывался как замена языку JavaScript. На данный момент чаще всего используется для разработки кроссплатформенных приложений в связкей с фреймворком Flutter.


Типы данных в dart:
 int - целые числа
 double - числа с плавающей запятой
 num - числовой тип, который может представлять целый числа(int) и числа с плавающей запятой(double)
 bool - логический тип данных, который может быть true или false
 string - 	строковый тип данных
 object - базовый тип от которого наследуются все другие типы данных. После dart 2.0 базовым типом является Object?
 dynamic - тип без статической проверки типов, который может содержать любой другой тип данных.


Коллекции в dart:
 List - упорядоченная коллекция элементов, которая может содержать дубликаты. Элементы в списке доступны по индексу.
 Set - коллекция уникальных элементов без упорядочения. Она не содержит дубликатов, и порядок элементов не гарантирован.
 Queue(очередь) - коллекция элементов, которая работает по принципу FIFO(первый пришел, первый ушел)
 Runes - коллекция для представления Unicode символов в строках.


Const и final 
Значение final  должно быть известно в runtime. Так же при использовании final переменная не может быть перезаписана, но обьект может изменяться.
Значение const должно быть известно на момент компиляции. Так же при использовании const нельзя изменять сам обьект(он иммутабельный).


Виды компиляции
JIT(Just-in-time) - компиляция кода происходит во время выполнения программы, так же компилятор запоминает часто используемые области кода. Данный вид компиляции значительно ускоряет процесс разработки, т.к. дает возможность использовать Hot Reload и Hot Restart.
AOT(Ahead-of-time) - компиляция кода происходит до выполнения программы. Дает более высокую производительность приложения, чем при использовании JIT-компиляции.


Hot Restart и Hot Reload
Hot Reload загружает изменения в Dart VM и ребилдит дерево виджетов, сохраняя состояние. Не перезапускает main() и initState().
Hot Restart загружает изменения в Dart VM и перезагружает всё приложение. Перезапускает main() и initState(). Состояние не сохраняется.


Late 
Late - ключевое слово, которое позволяет обьявить not-nulluble переменную и при этом не установить для нее значение.


Covariant
Сovariant - ключевое слово, которое указывает на то, что тип возвращаеммого значения может быть изменен на более узкий тип в подклассе.


Never
Never - это тип, означающий, что ни один тип не разрешен и Never сам по себе не может быть создан.


Аннотации
Аннотации — это синтаксические метаданные, которые могут быть добавлены к коду. Другими словами, это возможность добавить дополнительную информацию к любому компоненту кода, например, к классу или методу. Аннотации всегда начинаются с символа @ (@override, @required). Любой класс может служить аннотацией, если в нем определен const конструктор.


Event Loop
Event Loop - вечный цикл, выполняющий все поступающие в изолят задачи. В нём есть две FIFO очереди задач:

Очередь MicroTask
Используется для очень коротких действий, которые должны быть выполнены асинхронно, сразу после завершения какой-либо инструкции перед тем, как передать управление обратно Event Loop. Очередь MicroTask имеет приоритет перед очередью Event

Очередь Event
Используется для планирования операций, которые получают результат от внешних событий (операции ввода/вывода, жесты, рисование, таймеры, потоки)

Future
Future - это обёртка над результатом выполнения асинхронной операции. Код Future НЕ выполняется параллельно, а выполняется в последовательности, определяемой Event Loop.
Состояния Future:
 Uncompleted - операция не завершена
 Completed with Result - операция завершена успешно
 Completed with Error - операция завершена с ошибкой


Stream
Stream - это последовательность асинхронных событий. Stream сообщает вам, что есть событие и когда оно будет готово
 Single subscription - это вид потока, при котором может быть только один подписчик.
 Broadcast - это вид потока, при котором может быть много подписчиков. При этом Broadcast стримы отдают свои данные вне зависимости от того, подписан ли кто-нибудь на них или нет. Подписчики стрима получают события только с момента подписки, а не с момента старта жизни стрима.


Генераторы (sync* / async*)
Генератор это ключевое слово, которое позволяет создавать последовательность значений с помощью yield.
sync* - это синхронный генератор. Возвращает Iterable
async* - это aсинхронный генератор. Возвращает Stream


Многопоточность в Dart и Flutter
Dart — однопоточный язык программирования. Он исполняет одновременно одну инструкцию. Но при этом мы можем запустить код в отдельном поток с помощью Isolate.


Isolate
Isolate - это легковесный процесс (поток исполнения), который выполняется параллельно с другими потоками и процессами в приложении. Каждый Isolate в Dart имеет свой собственный экземпляр виртуальной машины Dart, собственную память и управляется с помощью своего Event Loop.


Compute
Compute - это функция, которая создаёт изолят и запускает переданный код.




**Flutter**


Widget 
Widget - иммутабельное описание конфигурации приложения.


Element 
Element - состояние конфигурации приложения.


Stateless и Stateful виджеты
StatelessWidget - это виджет, который не имеет состояния, в процессе работы приложения не изменяет своих свойств. Они могут изменяться лишь посредством внешних событий, которые возникают в родительских виджетах
StatefulWidget - это виджет, который хранит состояние, в процессе работы приложения он может его изменять динамически с помощью setState().
Также есть StatefulElement и StatelessElement.

Жизненный цикл Stateful виджета
 1.createState() вызывается единожды и создает изменяемое состояние для этого виджета в заданном месте в дереве
 2.mounted is true
 3.initState() вызывается единожды при инициализации
 4.didChangeDependencies() вызывается единожды после инициализации и далее при уведомлениях от Inhherited-виджетов вверху по дереву, от которых зависит виджет
 5.build() вызывается каждый раз при перерисовке
 6.didUpdateWidget(Widget oldWidget) вызывается каждый раз при обновлении конфигурации виджета
 7.setState() вызывается императивно для перерисовки
 8.deactivate() вызывается, когда ранее активный элемент перемещается в список неактивных элементов, при этом удаляясь из дерева
 9.dispose() вызывается, когда этот объект удаляется из дерева навсегда
 10.mounted is false
 

BuildContext
BuildContext - абстрактный класс, который отвечает за указатель виджета в дереве.
В build() метод виджета приходит BuildContext, а не сам Element, т.к. в элементе хранится много методов которые трогать не стоит


InheritedWidget
InheritedWidget — это виджет, который предоставляет своим потомкам возможность взаимодействовать с данными, хранящимися в нём. Решает проблему с передачей данных через конструкторы. Может уведомлять виджетов внизу по дереву об изменениях в собственных данных, тем самым провоцируя их перерисовку.
Для получения Inherited виджета необходимо вызвать context.dependOnInheritedWidgetOfExactType<T extends InheritedWidget>() в didChangeDependencies()
Сложность у операции получения InheritedWidget - O(1). Такая скорость достигается за счёт того, что Inherited виджеты хранятся в виде мапы в Element-е

Виды виджетов
Proxy - это виджеты, которые хранят некоторую информацию и делают её доступной для потомков. Эти виджеты не принимают непосредственного участия в формировании пользовательского интерфейса, но используются для получения информации, которую они могут предоставить.
InheritedWidget
ParentDataWidget (LayoutId, Flexible, KeepAlive и т.д.)
NotificationListener

Renderer - это виджеты, которые имеют непосредственное отношение к компоновке экрана, поскольку они определяют размеры, положение, отрисовку.
Row
Column
Stack
Padding
Align
Opacity

Component - это виджеты, которые предоставляют непосредственно не окончательную информацию, связанную с размерами, позициями, внешним видом, а скорее данные (или подсказки), которые будут использоваться для получения той самой финальной информации.
RaisedButton
Scaffold
Text
GestureDetector
Container

GlobalKeys
GlobalKeys - это ключи, которые предоставляют доступ к виджетам. Для виджетов с отслеживанием состояния глобальные ключи также предоставляют доступ к состоянию. Позволяют виджетам менять родителей в любом месте приложения без потери состояния. Должны быть уникальны для всего приложения.

LocalKeys
LocalKeys - это ключи, которые нужны для идентификации виджетов в коллекции с одинаковыми значениеми должны быть уникальными среди виджетов с одним и тем же родительским виджетом. Могут использоваться для тестов:
 ValueKey - это ключ, который использует значение определенного типа для идентификации самого себя. Переопределяет оператор сравнения. Если value одниковое, то ключи одинаковые
 UniqueKey - это ключ, который равен только самому себе
 ObjectKey - это ключ, который используется для привязки идентификатора виджета к идентификатору объекта, используемого для создания этого виджета.


BuildOwner
BuildOwner — менеджер сборки и обновления дерева элементов. Он активно участвует в двух фазах — сборки и завершения сборки. Поскольку BuildOwner управляет процессом сборки дерева, в нем хранятся списки неактивных элементов и списки элементов, нуждающихся в обновлении.
Методы:

scheduleBuildFor даёт возможность пометить элемент как нуждающийся в обновлении.
lockState защищает элемент от неправильного использования, утечек памяти и пометки на обновления в процессе уничтожения.
buildScope осуществляет пересборку дерева. Работает с элементами, которые помечены как нуждающиеся в обновлении.
finalizeTree завершает построение дерева. Удаляет неиспользуемые элементы и осуществляет дополнительные проверки в режиме отладки — в том числе на дублирование глобальных ключей.
reassemble обеспечивает работу механизма HotReload. Этот механизм позволяет не пересобирать проект при изменениях, а отправлять новую версию кода на DartVM и инициировать обновление дерева.


PipelineOwner
PipelineOwner — менеджер сборки, который занимается работой с деревом отображения.

 









 
 



 
 






